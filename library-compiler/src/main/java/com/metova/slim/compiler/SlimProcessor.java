package com.metova.slim.compiler;

import com.google.auto.common.SuperficialValidation;
import com.google.auto.service.AutoService;

import com.metova.slim.common.annotation.Callback;
import com.metova.slim.common.annotation.CallbackClick;
import com.metova.slim.common.annotation.Extra;
import com.metova.slim.common.annotation.Layout;
import com.metova.slim.common.provider.LayoutProvider;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;

import static javax.lang.model.element.ElementKind.CLASS;
import static javax.lang.model.element.ElementKind.INTERFACE;
import static javax.lang.model.element.ElementKind.METHOD;
import static javax.tools.Diagnostic.Kind.ERROR;

@AutoService(Processor.class)
public class SlimProcessor extends AbstractProcessor {

    private static final String BINDING_CLASS_SUFFIX = "$$SlimBinder";

    private Filer mFiler;

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return arrayToSet(new String[]{
                Callback.class.getCanonicalName(),
                CallbackClick.class.getCanonicalName(),
                Extra.class.getCanonicalName(),
                Layout.class.getCanonicalName()
        });
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        mFiler = processingEnv.getFiler();
    }

    @Override
    public boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {
        for (Element element : env.getElementsAnnotatedWith(Layout.class)) {
            if (!SuperficialValidation.validateElement(element)) {
                continue;
            }

            try {
                List<TypeName> interfaces = new ArrayList<>();
                List<MethodSpec> methods = new ArrayList<>();

                interfaces.add(TypeName.get(LayoutProvider.class));
                methods.add(parseLayout(element));

                String packageName = getPackageName(element);
                String className = getEnclosingClassName(element);
                createJavaFile(packageName, className + BINDING_CLASS_SUFFIX, interfaces, methods).writeTo(mFiler);
            } catch (IOException e) {
                error(element, "Unable to write binder class for type %s: %s", element.getSimpleName().toString(), e.getMessage());
            }
        }

        return true;
    }

    private MethodSpec parseLayout(Element element) throws IOException {
        Element methodElement = null;
        TypeElement providerElement = processingEnv.getElementUtils().getTypeElement(LayoutProvider.class.getCanonicalName());
        for (Element enclosedElement : providerElement.getEnclosedElements()) {
            if (enclosedElement.getKind() == METHOD && enclosedElement.getSimpleName().contentEquals("getLayoutId")) {
                methodElement = enclosedElement;
                break;
            }
        }

        if (methodElement == null) {
            throw new IOException("Method missing from interface");
        }

        int id = element.getAnnotation(Layout.class).value();
        return MethodSpec.overriding((ExecutableElement) methodElement)
                .addCode(CodeBlock.of("return $L;\n", id))
                .build();
    }

    private JavaFile createJavaFile(String packageName, String className, Iterable<TypeName> interfaces, Iterable<MethodSpec> methods) {
        TypeSpec.Builder builder = TypeSpec.classBuilder(className)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addSuperinterfaces(interfaces)
                .addMethods(methods);

        return JavaFile.builder(packageName, builder.build())
                .addFileComment("Generated by Slim. Do not modify!\n")
                .addFileComment(new Date(System.currentTimeMillis()).toString())
                .build();
    }

    private String getPackageName(Element type) {
        return processingEnv.getElementUtils().getPackageOf(type).getQualifiedName().toString();
    }

    private void error(Element element, String message, Object... args) {
        processingEnv.getMessager().printMessage(ERROR, String.format(message, args), element);
    }

    private static Set<String> arrayToSet(String[] array) {
        assert array != null;

        Set<String> set = new HashSet<>(array.length);
        Collections.addAll(set, array);

        return set;
    }

    private static String getEnclosingClassName(Element type) {
        if (type.getKind() != CLASS && type.getKind() != INTERFACE) {
            type = type.getEnclosingElement();
        }
        return type.getSimpleName().toString();
    }
}
